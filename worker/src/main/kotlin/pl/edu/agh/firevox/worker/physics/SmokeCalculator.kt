package pl.edu.agh.firevox.worker.physics

import org.springframework.stereotype.Service
import pl.edu.agh.firevox.shared.model.VoxelKey
import pl.edu.agh.firevox.worker.service.VoxelState
import kotlin.math.min

@Service
class SmokeCalculator {

    fun calculate(
        voxel: VoxelState,
        neighbours: List<VoxelState>,
        timeStep: Double,
        iteration: Int,
        voxelsToSend: MutableSet<VoxelKey>,
    ): Double {
        val upper = neighbours.firstOrNull { it.key.isAbove(voxel.key) }
        val canUpperAccept = upper?.let {
            !it.material.isSolid() && it.smokeConcentration + smokeTransfer(
                voxel.smokeConcentration,
                it.smokeConcentration
            ) < 1.0
        } ?: true // air is assumed boundary condition
        var gainedSmoke = 0.0
        var lostSmoke = 0.0
        for (n in neighbours) {
            // we know that voxel is a gas
            if (n.material.isSolid()) continue // neighbor is solid so no smoke transfer
            if (n.material.isLiquid()) continue // neighbor is liquid so no smoke transfer

            val voxelFactor = transferFactor(voxel.key, n.key, canUpperAccept)
            val nFactor = transferFactor(n.key, voxel.key, canUpperAccept)

            if (n.key.isBelow(voxel.key) && n.material.isBurning()) {
                // smoke is generated by flame
                gainedSmoke += generatedSmoke(n, timeStep)
                lostSmoke += 0.0
            } else {
                // smoke is transferred
                gainedSmoke += smokeTransfer(n.smokeConcentration, voxel.smokeConcentration) * voxelFactor
                lostSmoke += smokeTransfer(voxel.smokeConcentration, n.smokeConcentration) * nFactor
                voxelsToSend.add(n.key)
            }
        }
        return voxel.smokeConcentration + gainedSmoke - lostSmoke
    }

    private fun generatedSmoke(n: VoxelState, timeStep: Double): Double {
        return n.material.smokeEmissionPerSecond!! * timeStep
    }

    fun smokeTransfer(d0: Double, dn: Double) = min(d0 / 6, (1 - dn) / 6)
    fun transferFactor(voxelKey: VoxelKey, nKey: VoxelKey, upperCanAccept: Boolean): Double = if (upperCanAccept) {
        when {
            nKey.isAbove(voxelKey) -> 1.0
            nKey.isBelow(voxelKey) -> 0.25
            else -> 0.5
        }
    } else {
        when {
            nKey.isAbove(voxelKey) -> 0.0
            nKey.isBelow(voxelKey) -> 1.0
            else -> 0.5
        }
    }
}